/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef MutationLogger_H
#define MutationLogger_H

#include <TProcessor.h>
#include "tabletserver_types.h"

namespace accumulo { namespace tabletserver {

class MutationLoggerIf {
 public:
  virtual ~MutationLoggerIf() {}
  virtual void create(LogFile& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tserverSession) = 0;
  virtual void defineTablet(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TKeyExtent& tablet) = 0;
  virtual void log(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TMutation& mutation) = 0;
  virtual void logManyTablets(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const std::vector<TabletMutations> & mutations) = 0;
  virtual void minorCompactionStarted(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn) = 0;
  virtual void minorCompactionFinished(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn) = 0;
  virtual void close(const accumulo::cloudtrace::TInfo& tinfo, const LogID id) = 0;
  virtual void startCopy(LogCopyInfo& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& name, const std::string& fullyQualifiedFileName, const bool sort) = 0;
  virtual void getClosedLogs(std::vector<std::string> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) = 0;
  virtual void remove(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::vector<std::string> & files) = 0;
  virtual void beginShutdown(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) = 0;
  virtual void halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) = 0;
};

class MutationLoggerNull : virtual public MutationLoggerIf {
 public:
  virtual ~MutationLoggerNull() {}
  void create(LogFile& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* tserverSession */) {
    return;
  }
  void defineTablet(const accumulo::cloudtrace::TInfo& /* tinfo */, const LogID /* id */, const int64_t /* seq */, const TabletID /* tid */, const accumulo::data::TKeyExtent& /* tablet */) {
    return;
  }
  void log(const accumulo::cloudtrace::TInfo& /* tinfo */, const LogID /* id */, const int64_t /* seq */, const TabletID /* tid */, const accumulo::data::TMutation& /* mutation */) {
    return;
  }
  void logManyTablets(const accumulo::cloudtrace::TInfo& /* tinfo */, const LogID /* id */, const std::vector<TabletMutations> & /* mutations */) {
    return;
  }
  void minorCompactionStarted(const accumulo::cloudtrace::TInfo& /* tinfo */, const LogID /* id */, const int64_t /* seq */, const TabletID /* tid */, const std::string& /* fqfn */) {
    return;
  }
  void minorCompactionFinished(const accumulo::cloudtrace::TInfo& /* tinfo */, const LogID /* id */, const int64_t /* seq */, const TabletID /* tid */, const std::string& /* fqfn */) {
    return;
  }
  void close(const accumulo::cloudtrace::TInfo& /* tinfo */, const LogID /* id */) {
    return;
  }
  void startCopy(LogCopyInfo& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* name */, const std::string& /* fullyQualifiedFileName */, const bool /* sort */) {
    return;
  }
  void getClosedLogs(std::vector<std::string> & /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */) {
    return;
  }
  void remove(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::vector<std::string> & /* files */) {
    return;
  }
  void beginShutdown(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */) {
    return;
  }
  void halt(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */) {
    return;
  }
};

typedef struct _MutationLogger_create_args__isset {
  _MutationLogger_create_args__isset() : tinfo(false), credentials(false), tserverSession(false) {}
  bool tinfo;
  bool credentials;
  bool tserverSession;
} _MutationLogger_create_args__isset;

class MutationLogger_create_args {
 public:

  MutationLogger_create_args() : tserverSession("") {
  }

  virtual ~MutationLogger_create_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string tserverSession;

  _MutationLogger_create_args__isset __isset;

  bool operator == (const MutationLogger_create_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(tserverSession == rhs.tserverSession))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_create_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_create_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_create_pargs {
 public:


  virtual ~MutationLogger_create_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* tserverSession;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_create_result__isset {
  _MutationLogger_create_result__isset() : success(false), sec(false), lce(false) {}
  bool success;
  bool sec;
  bool lce;
} _MutationLogger_create_result__isset;

class MutationLogger_create_result {
 public:

  MutationLogger_create_result() {
  }

  virtual ~MutationLogger_create_result() throw() {}

  LogFile success;
  accumulo::security::ThriftSecurityException sec;
  LoggerClosedException lce;

  _MutationLogger_create_result__isset __isset;

  bool operator == (const MutationLogger_create_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    if (!(lce == rhs.lce))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_create_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_create_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_create_presult__isset {
  _MutationLogger_create_presult__isset() : success(false), sec(false), lce(false) {}
  bool success;
  bool sec;
  bool lce;
} _MutationLogger_create_presult__isset;

class MutationLogger_create_presult {
 public:


  virtual ~MutationLogger_create_presult() throw() {}

  LogFile* success;
  accumulo::security::ThriftSecurityException sec;
  LoggerClosedException lce;

  _MutationLogger_create_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_defineTablet_args__isset {
  _MutationLogger_defineTablet_args__isset() : tinfo(false), id(false), seq(false), tid(false), tablet(false) {}
  bool tinfo;
  bool id;
  bool seq;
  bool tid;
  bool tablet;
} _MutationLogger_defineTablet_args__isset;

class MutationLogger_defineTablet_args {
 public:

  MutationLogger_defineTablet_args() : id(0), seq(0), tid(0) {
  }

  virtual ~MutationLogger_defineTablet_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  LogID id;
  int64_t seq;
  TabletID tid;
  accumulo::data::TKeyExtent tablet;

  _MutationLogger_defineTablet_args__isset __isset;

  bool operator == (const MutationLogger_defineTablet_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(seq == rhs.seq))
      return false;
    if (!(tid == rhs.tid))
      return false;
    if (!(tablet == rhs.tablet))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_defineTablet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_defineTablet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_defineTablet_pargs {
 public:


  virtual ~MutationLogger_defineTablet_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const LogID* id;
  const int64_t* seq;
  const TabletID* tid;
  const accumulo::data::TKeyExtent* tablet;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_defineTablet_result__isset {
  _MutationLogger_defineTablet_result__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_defineTablet_result__isset;

class MutationLogger_defineTablet_result {
 public:

  MutationLogger_defineTablet_result() {
  }

  virtual ~MutationLogger_defineTablet_result() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_defineTablet_result__isset __isset;

  bool operator == (const MutationLogger_defineTablet_result & rhs) const
  {
    if (!(nsli == rhs.nsli))
      return false;
    if (!(lce == rhs.lce))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_defineTablet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_defineTablet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_defineTablet_presult__isset {
  _MutationLogger_defineTablet_presult__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_defineTablet_presult__isset;

class MutationLogger_defineTablet_presult {
 public:


  virtual ~MutationLogger_defineTablet_presult() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_defineTablet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_log_args__isset {
  _MutationLogger_log_args__isset() : tinfo(false), id(false), seq(false), tid(false), mutation(false) {}
  bool tinfo;
  bool id;
  bool seq;
  bool tid;
  bool mutation;
} _MutationLogger_log_args__isset;

class MutationLogger_log_args {
 public:

  MutationLogger_log_args() : id(0), seq(0), tid(0) {
  }

  virtual ~MutationLogger_log_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  LogID id;
  int64_t seq;
  TabletID tid;
  accumulo::data::TMutation mutation;

  _MutationLogger_log_args__isset __isset;

  bool operator == (const MutationLogger_log_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(seq == rhs.seq))
      return false;
    if (!(tid == rhs.tid))
      return false;
    if (!(mutation == rhs.mutation))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_log_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_log_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_log_pargs {
 public:


  virtual ~MutationLogger_log_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const LogID* id;
  const int64_t* seq;
  const TabletID* tid;
  const accumulo::data::TMutation* mutation;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_log_result__isset {
  _MutationLogger_log_result__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_log_result__isset;

class MutationLogger_log_result {
 public:

  MutationLogger_log_result() {
  }

  virtual ~MutationLogger_log_result() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_log_result__isset __isset;

  bool operator == (const MutationLogger_log_result & rhs) const
  {
    if (!(nsli == rhs.nsli))
      return false;
    if (!(lce == rhs.lce))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_log_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_log_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_log_presult__isset {
  _MutationLogger_log_presult__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_log_presult__isset;

class MutationLogger_log_presult {
 public:


  virtual ~MutationLogger_log_presult() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_log_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_logManyTablets_args__isset {
  _MutationLogger_logManyTablets_args__isset() : tinfo(false), id(false), mutations(false) {}
  bool tinfo;
  bool id;
  bool mutations;
} _MutationLogger_logManyTablets_args__isset;

class MutationLogger_logManyTablets_args {
 public:

  MutationLogger_logManyTablets_args() : id(0) {
  }

  virtual ~MutationLogger_logManyTablets_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  LogID id;
  std::vector<TabletMutations>  mutations;

  _MutationLogger_logManyTablets_args__isset __isset;

  bool operator == (const MutationLogger_logManyTablets_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_logManyTablets_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_logManyTablets_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_logManyTablets_pargs {
 public:


  virtual ~MutationLogger_logManyTablets_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const LogID* id;
  const std::vector<TabletMutations> * mutations;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_logManyTablets_result__isset {
  _MutationLogger_logManyTablets_result__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_logManyTablets_result__isset;

class MutationLogger_logManyTablets_result {
 public:

  MutationLogger_logManyTablets_result() {
  }

  virtual ~MutationLogger_logManyTablets_result() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_logManyTablets_result__isset __isset;

  bool operator == (const MutationLogger_logManyTablets_result & rhs) const
  {
    if (!(nsli == rhs.nsli))
      return false;
    if (!(lce == rhs.lce))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_logManyTablets_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_logManyTablets_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_logManyTablets_presult__isset {
  _MutationLogger_logManyTablets_presult__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_logManyTablets_presult__isset;

class MutationLogger_logManyTablets_presult {
 public:


  virtual ~MutationLogger_logManyTablets_presult() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_logManyTablets_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_minorCompactionStarted_args__isset {
  _MutationLogger_minorCompactionStarted_args__isset() : tinfo(false), id(false), seq(false), tid(false), fqfn(false) {}
  bool tinfo;
  bool id;
  bool seq;
  bool tid;
  bool fqfn;
} _MutationLogger_minorCompactionStarted_args__isset;

class MutationLogger_minorCompactionStarted_args {
 public:

  MutationLogger_minorCompactionStarted_args() : id(0), seq(0), tid(0), fqfn("") {
  }

  virtual ~MutationLogger_minorCompactionStarted_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  LogID id;
  int64_t seq;
  TabletID tid;
  std::string fqfn;

  _MutationLogger_minorCompactionStarted_args__isset __isset;

  bool operator == (const MutationLogger_minorCompactionStarted_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(seq == rhs.seq))
      return false;
    if (!(tid == rhs.tid))
      return false;
    if (!(fqfn == rhs.fqfn))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_minorCompactionStarted_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_minorCompactionStarted_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_minorCompactionStarted_pargs {
 public:


  virtual ~MutationLogger_minorCompactionStarted_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const LogID* id;
  const int64_t* seq;
  const TabletID* tid;
  const std::string* fqfn;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_minorCompactionStarted_result__isset {
  _MutationLogger_minorCompactionStarted_result__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_minorCompactionStarted_result__isset;

class MutationLogger_minorCompactionStarted_result {
 public:

  MutationLogger_minorCompactionStarted_result() {
  }

  virtual ~MutationLogger_minorCompactionStarted_result() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_minorCompactionStarted_result__isset __isset;

  bool operator == (const MutationLogger_minorCompactionStarted_result & rhs) const
  {
    if (!(nsli == rhs.nsli))
      return false;
    if (!(lce == rhs.lce))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_minorCompactionStarted_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_minorCompactionStarted_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_minorCompactionStarted_presult__isset {
  _MutationLogger_minorCompactionStarted_presult__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_minorCompactionStarted_presult__isset;

class MutationLogger_minorCompactionStarted_presult {
 public:


  virtual ~MutationLogger_minorCompactionStarted_presult() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_minorCompactionStarted_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_minorCompactionFinished_args__isset {
  _MutationLogger_minorCompactionFinished_args__isset() : tinfo(false), id(false), seq(false), tid(false), fqfn(false) {}
  bool tinfo;
  bool id;
  bool seq;
  bool tid;
  bool fqfn;
} _MutationLogger_minorCompactionFinished_args__isset;

class MutationLogger_minorCompactionFinished_args {
 public:

  MutationLogger_minorCompactionFinished_args() : id(0), seq(0), tid(0), fqfn("") {
  }

  virtual ~MutationLogger_minorCompactionFinished_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  LogID id;
  int64_t seq;
  TabletID tid;
  std::string fqfn;

  _MutationLogger_minorCompactionFinished_args__isset __isset;

  bool operator == (const MutationLogger_minorCompactionFinished_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(seq == rhs.seq))
      return false;
    if (!(tid == rhs.tid))
      return false;
    if (!(fqfn == rhs.fqfn))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_minorCompactionFinished_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_minorCompactionFinished_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_minorCompactionFinished_pargs {
 public:


  virtual ~MutationLogger_minorCompactionFinished_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const LogID* id;
  const int64_t* seq;
  const TabletID* tid;
  const std::string* fqfn;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_minorCompactionFinished_result__isset {
  _MutationLogger_minorCompactionFinished_result__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_minorCompactionFinished_result__isset;

class MutationLogger_minorCompactionFinished_result {
 public:

  MutationLogger_minorCompactionFinished_result() {
  }

  virtual ~MutationLogger_minorCompactionFinished_result() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_minorCompactionFinished_result__isset __isset;

  bool operator == (const MutationLogger_minorCompactionFinished_result & rhs) const
  {
    if (!(nsli == rhs.nsli))
      return false;
    if (!(lce == rhs.lce))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_minorCompactionFinished_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_minorCompactionFinished_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_minorCompactionFinished_presult__isset {
  _MutationLogger_minorCompactionFinished_presult__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_minorCompactionFinished_presult__isset;

class MutationLogger_minorCompactionFinished_presult {
 public:


  virtual ~MutationLogger_minorCompactionFinished_presult() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_minorCompactionFinished_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_close_args__isset {
  _MutationLogger_close_args__isset() : tinfo(false), id(false) {}
  bool tinfo;
  bool id;
} _MutationLogger_close_args__isset;

class MutationLogger_close_args {
 public:

  MutationLogger_close_args() : id(0) {
  }

  virtual ~MutationLogger_close_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  LogID id;

  _MutationLogger_close_args__isset __isset;

  bool operator == (const MutationLogger_close_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_close_pargs {
 public:


  virtual ~MutationLogger_close_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const LogID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_close_result__isset {
  _MutationLogger_close_result__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_close_result__isset;

class MutationLogger_close_result {
 public:

  MutationLogger_close_result() {
  }

  virtual ~MutationLogger_close_result() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_close_result__isset __isset;

  bool operator == (const MutationLogger_close_result & rhs) const
  {
    if (!(nsli == rhs.nsli))
      return false;
    if (!(lce == rhs.lce))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_close_presult__isset {
  _MutationLogger_close_presult__isset() : nsli(false), lce(false) {}
  bool nsli;
  bool lce;
} _MutationLogger_close_presult__isset;

class MutationLogger_close_presult {
 public:


  virtual ~MutationLogger_close_presult() throw() {}

  NoSuchLogIDException nsli;
  LoggerClosedException lce;

  _MutationLogger_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_startCopy_args__isset {
  _MutationLogger_startCopy_args__isset() : tinfo(false), credentials(false), name(false), fullyQualifiedFileName(false), sort(false) {}
  bool tinfo;
  bool credentials;
  bool name;
  bool fullyQualifiedFileName;
  bool sort;
} _MutationLogger_startCopy_args__isset;

class MutationLogger_startCopy_args {
 public:

  MutationLogger_startCopy_args() : name(""), fullyQualifiedFileName(""), sort(0) {
  }

  virtual ~MutationLogger_startCopy_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string name;
  std::string fullyQualifiedFileName;
  bool sort;

  _MutationLogger_startCopy_args__isset __isset;

  bool operator == (const MutationLogger_startCopy_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(fullyQualifiedFileName == rhs.fullyQualifiedFileName))
      return false;
    if (!(sort == rhs.sort))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_startCopy_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_startCopy_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_startCopy_pargs {
 public:


  virtual ~MutationLogger_startCopy_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* name;
  const std::string* fullyQualifiedFileName;
  const bool* sort;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_startCopy_result__isset {
  _MutationLogger_startCopy_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _MutationLogger_startCopy_result__isset;

class MutationLogger_startCopy_result {
 public:

  MutationLogger_startCopy_result() {
  }

  virtual ~MutationLogger_startCopy_result() throw() {}

  LogCopyInfo success;
  accumulo::security::ThriftSecurityException sec;

  _MutationLogger_startCopy_result__isset __isset;

  bool operator == (const MutationLogger_startCopy_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_startCopy_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_startCopy_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_startCopy_presult__isset {
  _MutationLogger_startCopy_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _MutationLogger_startCopy_presult__isset;

class MutationLogger_startCopy_presult {
 public:


  virtual ~MutationLogger_startCopy_presult() throw() {}

  LogCopyInfo* success;
  accumulo::security::ThriftSecurityException sec;

  _MutationLogger_startCopy_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_getClosedLogs_args__isset {
  _MutationLogger_getClosedLogs_args__isset() : tinfo(false), credentials(false) {}
  bool tinfo;
  bool credentials;
} _MutationLogger_getClosedLogs_args__isset;

class MutationLogger_getClosedLogs_args {
 public:

  MutationLogger_getClosedLogs_args() {
  }

  virtual ~MutationLogger_getClosedLogs_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;

  _MutationLogger_getClosedLogs_args__isset __isset;

  bool operator == (const MutationLogger_getClosedLogs_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_getClosedLogs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_getClosedLogs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_getClosedLogs_pargs {
 public:


  virtual ~MutationLogger_getClosedLogs_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_getClosedLogs_result__isset {
  _MutationLogger_getClosedLogs_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _MutationLogger_getClosedLogs_result__isset;

class MutationLogger_getClosedLogs_result {
 public:

  MutationLogger_getClosedLogs_result() {
  }

  virtual ~MutationLogger_getClosedLogs_result() throw() {}

  std::vector<std::string>  success;
  accumulo::security::ThriftSecurityException sec;

  _MutationLogger_getClosedLogs_result__isset __isset;

  bool operator == (const MutationLogger_getClosedLogs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_getClosedLogs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_getClosedLogs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_getClosedLogs_presult__isset {
  _MutationLogger_getClosedLogs_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _MutationLogger_getClosedLogs_presult__isset;

class MutationLogger_getClosedLogs_presult {
 public:


  virtual ~MutationLogger_getClosedLogs_presult() throw() {}

  std::vector<std::string> * success;
  accumulo::security::ThriftSecurityException sec;

  _MutationLogger_getClosedLogs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_remove_args__isset {
  _MutationLogger_remove_args__isset() : tinfo(false), credentials(false), files(false) {}
  bool tinfo;
  bool credentials;
  bool files;
} _MutationLogger_remove_args__isset;

class MutationLogger_remove_args {
 public:

  MutationLogger_remove_args() {
  }

  virtual ~MutationLogger_remove_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::vector<std::string>  files;

  _MutationLogger_remove_args__isset __isset;

  bool operator == (const MutationLogger_remove_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_remove_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_remove_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_remove_pargs {
 public:


  virtual ~MutationLogger_remove_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::vector<std::string> * files;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_beginShutdown_args__isset {
  _MutationLogger_beginShutdown_args__isset() : tinfo(false), credentials(false) {}
  bool tinfo;
  bool credentials;
} _MutationLogger_beginShutdown_args__isset;

class MutationLogger_beginShutdown_args {
 public:

  MutationLogger_beginShutdown_args() {
  }

  virtual ~MutationLogger_beginShutdown_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;

  _MutationLogger_beginShutdown_args__isset __isset;

  bool operator == (const MutationLogger_beginShutdown_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_beginShutdown_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_beginShutdown_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_beginShutdown_pargs {
 public:


  virtual ~MutationLogger_beginShutdown_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_beginShutdown_result__isset {
  _MutationLogger_beginShutdown_result__isset() : sec(false) {}
  bool sec;
} _MutationLogger_beginShutdown_result__isset;

class MutationLogger_beginShutdown_result {
 public:

  MutationLogger_beginShutdown_result() {
  }

  virtual ~MutationLogger_beginShutdown_result() throw() {}

  accumulo::security::ThriftSecurityException sec;

  _MutationLogger_beginShutdown_result__isset __isset;

  bool operator == (const MutationLogger_beginShutdown_result & rhs) const
  {
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_beginShutdown_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_beginShutdown_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MutationLogger_beginShutdown_presult__isset {
  _MutationLogger_beginShutdown_presult__isset() : sec(false) {}
  bool sec;
} _MutationLogger_beginShutdown_presult__isset;

class MutationLogger_beginShutdown_presult {
 public:


  virtual ~MutationLogger_beginShutdown_presult() throw() {}

  accumulo::security::ThriftSecurityException sec;

  _MutationLogger_beginShutdown_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MutationLogger_halt_args__isset {
  _MutationLogger_halt_args__isset() : tinfo(false), credentials(false) {}
  bool tinfo;
  bool credentials;
} _MutationLogger_halt_args__isset;

class MutationLogger_halt_args {
 public:

  MutationLogger_halt_args() {
  }

  virtual ~MutationLogger_halt_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;

  _MutationLogger_halt_args__isset __isset;

  bool operator == (const MutationLogger_halt_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    return true;
  }
  bool operator != (const MutationLogger_halt_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutationLogger_halt_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MutationLogger_halt_pargs {
 public:


  virtual ~MutationLogger_halt_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class MutationLoggerClient : virtual public MutationLoggerIf {
 public:
  MutationLoggerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  MutationLoggerClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void create(LogFile& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tserverSession);
  void send_create(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tserverSession);
  void recv_create(LogFile& _return);
  void defineTablet(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TKeyExtent& tablet);
  void send_defineTablet(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TKeyExtent& tablet);
  void recv_defineTablet();
  void log(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TMutation& mutation);
  void send_log(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TMutation& mutation);
  void recv_log();
  void logManyTablets(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const std::vector<TabletMutations> & mutations);
  void send_logManyTablets(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const std::vector<TabletMutations> & mutations);
  void recv_logManyTablets();
  void minorCompactionStarted(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn);
  void send_minorCompactionStarted(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn);
  void recv_minorCompactionStarted();
  void minorCompactionFinished(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn);
  void send_minorCompactionFinished(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn);
  void recv_minorCompactionFinished();
  void close(const accumulo::cloudtrace::TInfo& tinfo, const LogID id);
  void send_close(const accumulo::cloudtrace::TInfo& tinfo, const LogID id);
  void recv_close();
  void startCopy(LogCopyInfo& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& name, const std::string& fullyQualifiedFileName, const bool sort);
  void send_startCopy(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& name, const std::string& fullyQualifiedFileName, const bool sort);
  void recv_startCopy(LogCopyInfo& _return);
  void getClosedLogs(std::vector<std::string> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void send_getClosedLogs(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void recv_getClosedLogs(std::vector<std::string> & _return);
  void remove(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::vector<std::string> & files);
  void send_remove(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::vector<std::string> & files);
  void beginShutdown(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void send_beginShutdown(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void recv_beginShutdown();
  void halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void send_halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class MutationLoggerProcessor : virtual public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<MutationLoggerIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (MutationLoggerProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_defineTablet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_log(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_logManyTablets(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_minorCompactionStarted(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_minorCompactionFinished(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_startCopy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getClosedLogs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_beginShutdown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_halt(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  MutationLoggerProcessor(boost::shared_ptr<MutationLoggerIf> iface) :
    iface_(iface) {
    processMap_["create"] = &MutationLoggerProcessor::process_create;
    processMap_["defineTablet"] = &MutationLoggerProcessor::process_defineTablet;
    processMap_["log"] = &MutationLoggerProcessor::process_log;
    processMap_["logManyTablets"] = &MutationLoggerProcessor::process_logManyTablets;
    processMap_["minorCompactionStarted"] = &MutationLoggerProcessor::process_minorCompactionStarted;
    processMap_["minorCompactionFinished"] = &MutationLoggerProcessor::process_minorCompactionFinished;
    processMap_["close"] = &MutationLoggerProcessor::process_close;
    processMap_["startCopy"] = &MutationLoggerProcessor::process_startCopy;
    processMap_["getClosedLogs"] = &MutationLoggerProcessor::process_getClosedLogs;
    processMap_["remove"] = &MutationLoggerProcessor::process_remove;
    processMap_["beginShutdown"] = &MutationLoggerProcessor::process_beginShutdown;
    processMap_["halt"] = &MutationLoggerProcessor::process_halt;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~MutationLoggerProcessor() {}
};

class MutationLoggerMultiface : virtual public MutationLoggerIf {
 public:
  MutationLoggerMultiface(std::vector<boost::shared_ptr<MutationLoggerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~MutationLoggerMultiface() {}
 protected:
  std::vector<boost::shared_ptr<MutationLoggerIf> > ifaces_;
  MutationLoggerMultiface() {}
  void add(boost::shared_ptr<MutationLoggerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void create(LogFile& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tserverSession) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->create(_return, tinfo, credentials, tserverSession);
        return;
      } else {
        ifaces_[i]->create(_return, tinfo, credentials, tserverSession);
      }
    }
  }

  void defineTablet(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TKeyExtent& tablet) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->defineTablet(tinfo, id, seq, tid, tablet);
    }
  }

  void log(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const accumulo::data::TMutation& mutation) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->log(tinfo, id, seq, tid, mutation);
    }
  }

  void logManyTablets(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const std::vector<TabletMutations> & mutations) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->logManyTablets(tinfo, id, mutations);
    }
  }

  void minorCompactionStarted(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->minorCompactionStarted(tinfo, id, seq, tid, fqfn);
    }
  }

  void minorCompactionFinished(const accumulo::cloudtrace::TInfo& tinfo, const LogID id, const int64_t seq, const TabletID tid, const std::string& fqfn) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->minorCompactionFinished(tinfo, id, seq, tid, fqfn);
    }
  }

  void close(const accumulo::cloudtrace::TInfo& tinfo, const LogID id) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->close(tinfo, id);
    }
  }

  void startCopy(LogCopyInfo& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& name, const std::string& fullyQualifiedFileName, const bool sort) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->startCopy(_return, tinfo, credentials, name, fullyQualifiedFileName, sort);
        return;
      } else {
        ifaces_[i]->startCopy(_return, tinfo, credentials, name, fullyQualifiedFileName, sort);
      }
    }
  }

  void getClosedLogs(std::vector<std::string> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getClosedLogs(_return, tinfo, credentials);
        return;
      } else {
        ifaces_[i]->getClosedLogs(_return, tinfo, credentials);
      }
    }
  }

  void remove(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::vector<std::string> & files) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->remove(tinfo, credentials, files);
    }
  }

  void beginShutdown(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->beginShutdown(tinfo, credentials);
    }
  }

  void halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->halt(tinfo, credentials);
    }
  }

};

}} // namespace

#endif
