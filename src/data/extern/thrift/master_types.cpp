/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "master_types.h"

namespace accumulo { namespace master {

int _kMasterStateValues[] = {
  MasterState::INITIAL,
  MasterState::HAVE_LOCK,
  MasterState::SAFE_MODE,
  MasterState::NORMAL,
  MasterState::UNLOAD_METADATA_TABLETS,
  MasterState::UNLOAD_ROOT_TABLET,
  MasterState::STOP
};
const char* _kMasterStateNames[] = {
  "INITIAL",
  "HAVE_LOCK",
  "SAFE_MODE",
  "NORMAL",
  "UNLOAD_METADATA_TABLETS",
  "UNLOAD_ROOT_TABLET",
  "STOP"
};
const std::map<int, const char*> _MasterState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMasterStateValues, _kMasterStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMasterGoalStateValues[] = {
  MasterGoalState::CLEAN_STOP,
  MasterGoalState::SAFE_MODE,
  MasterGoalState::NORMAL
};
const char* _kMasterGoalStateNames[] = {
  "CLEAN_STOP",
  "SAFE_MODE",
  "NORMAL"
};
const std::map<int, const char*> _MasterGoalState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMasterGoalStateValues, _kMasterGoalStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTabletLoadStateValues[] = {
  TabletLoadState::LOADED,
  TabletLoadState::LOAD_FAILURE,
  TabletLoadState::UNLOADED,
  TabletLoadState::UNLOAD_FAILURE_NOT_SERVING,
  TabletLoadState::UNLOAD_ERROR,
  TabletLoadState::CHOPPED
};
const char* _kTabletLoadStateNames[] = {
  "LOADED",
  "LOAD_FAILURE",
  "UNLOADED",
  "UNLOAD_FAILURE_NOT_SERVING",
  "UNLOAD_ERROR",
  "CHOPPED"
};
const std::map<int, const char*> _TabletLoadState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTabletLoadStateValues, _kTabletLoadStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTableOperationValues[] = {
  TableOperation::CREATE,
  TableOperation::CLONE,
  TableOperation::DELETE,
  TableOperation::RENAME,
  TableOperation::ONLINE,
  TableOperation::OFFLINE,
  TableOperation::MERGE,
  TableOperation::DELETE_RANGE,
  TableOperation::BULK_IMPORT,
  TableOperation::COMPACT
};
const char* _kTableOperationNames[] = {
  "CREATE",
  "CLONE",
  "DELETE",
  "RENAME",
  "ONLINE",
  "OFFLINE",
  "MERGE",
  "DELETE_RANGE",
  "BULK_IMPORT",
  "COMPACT"
};
const std::map<int, const char*> _TableOperation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kTableOperationValues, _kTableOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Compacting::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t Compacting::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t Compacting::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->running);
          this->__isset.running = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queued);
          this->__isset.queued = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Compacting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Compacting");
  xfer += oprot->writeFieldBegin("running", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->running);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("queued", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->queued);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TableInfo::ascii_fingerprint = "4B3A524368C4ED01FE2A63BDC5D3303F";
const uint8_t TableInfo::binary_fingerprint[16] = {0x4B,0x3A,0x52,0x43,0x68,0xC4,0xED,0x01,0xFE,0x2A,0x63,0xBD,0xC5,0xD3,0x30,0x3F};

uint32_t TableInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recs);
          this->__isset.recs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recsInMemory);
          this->__isset.recsInMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tablets);
          this->__isset.tablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->onlineTablets);
          this->__isset.onlineTablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ingestRate);
          this->__isset.ingestRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ingestByteRate);
          this->__isset.ingestByteRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->queryRate);
          this->__isset.queryRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->queryByteRate);
          this->__isset.queryByteRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cminor.read(iprot);
          this->__isset.cminor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmajor.read(iprot);
          this->__isset.cmajor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scans.read(iprot);
          this->__isset.scans = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TableInfo");
  xfer += oprot->writeFieldBegin("recs", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->recs);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("recsInMemory", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->recsInMemory);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("tablets", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->tablets);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("onlineTablets", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->onlineTablets);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ingestRate", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->ingestRate);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ingestByteRate", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->ingestByteRate);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("queryRate", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->queryRate);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("queryByteRate", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->queryByteRate);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("minor", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->cminor.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("major", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->cmajor.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("scans", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->scans.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* RecoveryStatus::ascii_fingerprint = "C079FBBCC92CA77299012F16E5375E37";
const uint8_t RecoveryStatus::binary_fingerprint[16] = {0xC0,0x79,0xFB,0xBC,0xC9,0x2C,0xA7,0x72,0x99,0x01,0x2F,0x16,0xE5,0x37,0x5E,0x37};

uint32_t RecoveryStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->mapProgress);
          this->__isset.mapProgress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->reduceProgress);
          this->__isset.reduceProgress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->runtime);
          this->__isset.runtime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->copyProgress);
          this->__isset.copyProgress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RecoveryStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RecoveryStatus");
  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("mapProgress", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->mapProgress);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("reduceProgress", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->reduceProgress);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("runtime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->runtime);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("copyProgress", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->copyProgress);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* LoggerStatus::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t LoggerStatus::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t LoggerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->logger);
          this->__isset.logger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoggerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LoggerStatus");
  xfer += oprot->writeFieldBegin("logger", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->logger);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TabletServerStatus::ascii_fingerprint = "E24E36FA7C693A90B1E30F33F367C117";
const uint8_t TabletServerStatus::binary_fingerprint[16] = {0xE2,0x4E,0x36,0xFA,0x7C,0x69,0x3A,0x90,0xB1,0xE3,0x0F,0x33,0xF3,0x67,0xC1,0x17};

uint32_t TabletServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tableMap.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              TableInfo& _val6 = this->tableMap[_key5];
              xfer += _val6.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.tableMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastContact);
          this->__isset.lastContact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->osLoad);
          this->__isset.osLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->holdTime);
          this->__isset.holdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lookups);
          this->__isset.lookups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->loggers.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            iprot->readSetBegin(_etype10, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _elem12;
              xfer += iprot->readString(_elem12);
              this->loggers.insert(_elem12);
            }
            iprot->readSetEnd();
          }
          this->__isset.loggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->indexCacheHits);
          this->__isset.indexCacheHits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->indexCacheRequest);
          this->__isset.indexCacheRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dataCacheHits);
          this->__isset.dataCacheHits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dataCacheRequest);
          this->__isset.dataCacheRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TabletServerStatus");
  xfer += oprot->writeFieldBegin("tableMap", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, this->tableMap.size());
    std::map<std::string, TableInfo> ::const_iterator _iter13;
    for (_iter13 = this->tableMap.begin(); _iter13 != this->tableMap.end(); ++_iter13)
    {
      xfer += oprot->writeString(_iter13->first);
      xfer += _iter13->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("lastContact", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lastContact);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("osLoad", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->osLoad);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("holdTime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->holdTime);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("lookups", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->lookups);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("loggers", ::apache::thrift::protocol::T_SET, 9);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, this->loggers.size());
    std::set<std::string> ::const_iterator _iter14;
    for (_iter14 = this->loggers.begin(); _iter14 != this->loggers.end(); ++_iter14)
    {
      xfer += oprot->writeString((*_iter14));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("indexCacheHits", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->indexCacheHits);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("indexCacheRequest", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->indexCacheRequest);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dataCacheHits", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->dataCacheHits);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dataCacheRequest", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->dataCacheRequest);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* DeadServer::ascii_fingerprint = "FA35BEC6F4D26D79A7E0AD1366489BCC";
const uint8_t DeadServer::binary_fingerprint[16] = {0xFA,0x35,0xBE,0xC6,0xF4,0xD2,0x6D,0x79,0xA7,0xE0,0xAD,0x13,0x66,0x48,0x9B,0xCC};

uint32_t DeadServer::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server);
          this->__isset.server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastStatus);
          this->__isset.lastStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeadServer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DeadServer");
  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->server);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("lastStatus", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lastStatus);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* MasterMonitorInfo::ascii_fingerprint = "EDB4BC8931448BEE8465A9E2F522A04A";
const uint8_t MasterMonitorInfo::binary_fingerprint[16] = {0xED,0xB4,0xBC,0x89,0x31,0x44,0x8B,0xEE,0x84,0x65,0xA9,0xE2,0xF5,0x22,0xA0,0x4A};

uint32_t MasterMonitorInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tableMap.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _ktype16;
            ::apache::thrift::protocol::TType _vtype17;
            iprot->readMapBegin(_ktype16, _vtype17, _size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              std::string _key20;
              xfer += iprot->readString(_key20);
              TableInfo& _val21 = this->tableMap[_key20];
              xfer += _val21.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.tableMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tServerInfo.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            iprot->readListBegin(_etype25, _size22);
            this->tServerInfo.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->tServerInfo[_i26].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.tServerInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->badTServers.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _ktype28;
            ::apache::thrift::protocol::TType _vtype29;
            iprot->readMapBegin(_ktype28, _vtype29, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              std::string _key32;
              xfer += iprot->readString(_key32);
              int8_t& _val33 = this->badTServers[_key32];
              xfer += iprot->readByte(_val33);
            }
            iprot->readMapEnd();
          }
          this->__isset.badTServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->recovery.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            iprot->readListBegin(_etype37, _size34);
            this->recovery.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->recovery[_i38].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.recovery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->loggers.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            iprot->readListBegin(_etype42, _size39);
            this->loggers.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->loggers[_i43].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.loggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast44;
          xfer += iprot->readI32(ecast44);
          this->state = (MasterState::type)ecast44;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast45;
          xfer += iprot->readI32(ecast45);
          this->goalState = (MasterGoalState::type)ecast45;
          this->__isset.goalState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->unassignedTablets);
          this->__isset.unassignedTablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serversShuttingDown.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            iprot->readSetBegin(_etype49, _size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              std::string _elem51;
              xfer += iprot->readString(_elem51);
              this->serversShuttingDown.insert(_elem51);
            }
            iprot->readSetEnd();
          }
          this->__isset.serversShuttingDown = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deadTabletServers.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            iprot->readListBegin(_etype55, _size52);
            this->deadTabletServers.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->deadTabletServers[_i56].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.deadTabletServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deadLoggers.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            iprot->readListBegin(_etype60, _size57);
            this->deadLoggers.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->deadLoggers[_i61].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.deadLoggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MasterMonitorInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MasterMonitorInfo");
  xfer += oprot->writeFieldBegin("tableMap", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, this->tableMap.size());
    std::map<std::string, TableInfo> ::const_iterator _iter62;
    for (_iter62 = this->tableMap.begin(); _iter62 != this->tableMap.end(); ++_iter62)
    {
      xfer += oprot->writeString(_iter62->first);
      xfer += _iter62->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("tServerInfo", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->tServerInfo.size());
    std::vector<TabletServerStatus> ::const_iterator _iter63;
    for (_iter63 = this->tServerInfo.begin(); _iter63 != this->tServerInfo.end(); ++_iter63)
    {
      xfer += (*_iter63).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("badTServers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_BYTE, this->badTServers.size());
    std::map<std::string, int8_t> ::const_iterator _iter64;
    for (_iter64 = this->badTServers.begin(); _iter64 != this->badTServers.end(); ++_iter64)
    {
      xfer += oprot->writeString(_iter64->first);
      xfer += oprot->writeByte(_iter64->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("recovery", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->recovery.size());
    std::vector<RecoveryStatus> ::const_iterator _iter65;
    for (_iter65 = this->recovery.begin(); _iter65 != this->recovery.end(); ++_iter65)
    {
      xfer += (*_iter65).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("loggers", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->loggers.size());
    std::vector<LoggerStatus> ::const_iterator _iter66;
    for (_iter66 = this->loggers.begin(); _iter66 != this->loggers.end(); ++_iter66)
    {
      xfer += (*_iter66).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("unassignedTablets", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->unassignedTablets);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("goalState", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->goalState);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("serversShuttingDown", ::apache::thrift::protocol::T_SET, 9);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, this->serversShuttingDown.size());
    std::set<std::string> ::const_iterator _iter67;
    for (_iter67 = this->serversShuttingDown.begin(); _iter67 != this->serversShuttingDown.end(); ++_iter67)
    {
      xfer += oprot->writeString((*_iter67));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("deadTabletServers", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->deadTabletServers.size());
    std::vector<DeadServer> ::const_iterator _iter68;
    for (_iter68 = this->deadTabletServers.begin(); _iter68 != this->deadTabletServers.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("deadLoggers", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->deadLoggers.size());
    std::vector<DeadServer> ::const_iterator _iter69;
    for (_iter69 = this->deadLoggers.begin(); _iter69 != this->deadLoggers.end(); ++_iter69)
    {
      xfer += (*_iter69).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TabletSplit::ascii_fingerprint = "512446FDB691C6A2252369D371A5BDE9";
const uint8_t TabletSplit::binary_fingerprint[16] = {0x51,0x24,0x46,0xFD,0xB6,0x91,0xC6,0xA2,0x25,0x23,0x69,0xD3,0x71,0xA5,0xBD,0xE9};

uint32_t TabletSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->oldTablet.read(iprot);
          this->__isset.oldTablet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->newTablets.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            iprot->readListBegin(_etype73, _size70);
            this->newTablets.resize(_size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              xfer += this->newTablets[_i74].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.newTablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TabletSplit");
  xfer += oprot->writeFieldBegin("oldTablet", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->oldTablet.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("newTablets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->newTablets.size());
    std::vector<accumulo::data::TKeyExtent> ::const_iterator _iter75;
    for (_iter75 = this->newTablets.begin(); _iter75 != this->newTablets.end(); ++_iter75)
    {
      xfer += (*_iter75).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* RecoveryException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t RecoveryException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t RecoveryException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RecoveryException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RecoveryException");
  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

}} // namespace
