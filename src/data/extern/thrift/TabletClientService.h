/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef TabletClientService_H
#define TabletClientService_H

#include <TProcessor.h>
#include "tabletserver_types.h"
#include "ClientService.h"

namespace accumulo { namespace tabletserver {

class TabletClientServiceIf : virtual public accumulo::client::ClientServiceIf {
 public:
  virtual ~TabletClientServiceIf() {}
  virtual void startScan(accumulo::data::InitialScan& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const accumulo::data::TRange& range, const std::vector<accumulo::data::TColumn> & columns, const int32_t batchSize, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated) = 0;
  virtual void continueScan(accumulo::data::ScanResult& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) = 0;
  virtual void closeScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) = 0;
  virtual void startMultiScan(accumulo::data::InitialMultiScan& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::ScanBatch& batch, const std::vector<accumulo::data::TColumn> & columns, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites) = 0;
  virtual void continueMultiScan(accumulo::data::MultiScanResult& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) = 0;
  virtual void closeMultiScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) = 0;
  virtual accumulo::data::UpdateID startUpdate(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) = 0;
  virtual void applyUpdates(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID, const accumulo::data::TKeyExtent& keyExtent, const std::vector<accumulo::data::TMutation> & mutations) = 0;
  virtual void closeUpdate(accumulo::data::UpdateErrors& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID) = 0;
  virtual void update(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& keyExtent, const accumulo::data::TMutation& mutation) = 0;
  virtual void bulkImport(std::vector<accumulo::data::TKeyExtent> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const int64_t tid, const accumulo::data::TabletFiles& files, const bool setTime) = 0;
  virtual void splitTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const std::string& splitPoint) = 0;
  virtual void loadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent) = 0;
  virtual void unloadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent, const bool save) = 0;
  virtual void flush(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow) = 0;
  virtual void flushTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent) = 0;
  virtual void chop(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent) = 0;
  virtual void compact(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow) = 0;
  virtual void useLoggers(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::set<std::string> & loggers) = 0;
  virtual void getTabletServerStatus(accumulo::master::TabletServerStatus& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) = 0;
  virtual void getTabletStats(std::vector<TabletStats> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tableId) = 0;
  virtual void getHistoricalStats(TabletStats& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) = 0;
  virtual void halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock) = 0;
  virtual void fastHalt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock) = 0;
  virtual void getActiveScans(std::vector<ActiveScan> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) = 0;
};

class TabletClientServiceNull : virtual public TabletClientServiceIf , virtual public accumulo::client::ClientServiceNull {
 public:
  virtual ~TabletClientServiceNull() {}
  void startScan(accumulo::data::InitialScan& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const accumulo::data::TKeyExtent& /* extent */, const accumulo::data::TRange& /* range */, const std::vector<accumulo::data::TColumn> & /* columns */, const int32_t /* batchSize */, const std::vector<accumulo::data::IterInfo> & /* ssiList */, const std::map<std::string, std::map<std::string, std::string> > & /* ssio */, const std::vector<std::string> & /* authorizations */, const bool /* waitForWrites */, const bool /* isolated */) {
    return;
  }
  void continueScan(accumulo::data::ScanResult& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::data::ScanID /* scanID */) {
    return;
  }
  void closeScan(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::data::ScanID /* scanID */) {
    return;
  }
  void startMultiScan(accumulo::data::InitialMultiScan& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const accumulo::data::ScanBatch& /* batch */, const std::vector<accumulo::data::TColumn> & /* columns */, const std::vector<accumulo::data::IterInfo> & /* ssiList */, const std::map<std::string, std::map<std::string, std::string> > & /* ssio */, const std::vector<std::string> & /* authorizations */, const bool /* waitForWrites */) {
    return;
  }
  void continueMultiScan(accumulo::data::MultiScanResult& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::data::ScanID /* scanID */) {
    return;
  }
  void closeMultiScan(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::data::ScanID /* scanID */) {
    return;
  }
  accumulo::data::UpdateID startUpdate(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */) {
    accumulo::data::UpdateID _return = 0;
    return _return;
  }
  void applyUpdates(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::data::UpdateID /* updateID */, const accumulo::data::TKeyExtent& /* keyExtent */, const std::vector<accumulo::data::TMutation> & /* mutations */) {
    return;
  }
  void closeUpdate(accumulo::data::UpdateErrors& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::data::UpdateID /* updateID */) {
    return;
  }
  void update(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const accumulo::data::TKeyExtent& /* keyExtent */, const accumulo::data::TMutation& /* mutation */) {
    return;
  }
  void bulkImport(std::vector<accumulo::data::TKeyExtent> & /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const int64_t /* tid */, const accumulo::data::TabletFiles& /* files */, const bool /* setTime */) {
    return;
  }
  void splitTablet(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const accumulo::data::TKeyExtent& /* extent */, const std::string& /* splitPoint */) {
    return;
  }
  void loadTablet(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */, const accumulo::data::TKeyExtent& /* extent */) {
    return;
  }
  void unloadTablet(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */, const accumulo::data::TKeyExtent& /* extent */, const bool /* save */) {
    return;
  }
  void flush(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */, const std::string& /* tableId */, const std::string& /* startRow */, const std::string& /* endRow */) {
    return;
  }
  void flushTablet(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */, const accumulo::data::TKeyExtent& /* extent */) {
    return;
  }
  void chop(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */, const accumulo::data::TKeyExtent& /* extent */) {
    return;
  }
  void compact(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */, const std::string& /* tableId */, const std::string& /* startRow */, const std::string& /* endRow */) {
    return;
  }
  void useLoggers(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::set<std::string> & /* loggers */) {
    return;
  }
  void getTabletServerStatus(accumulo::master::TabletServerStatus& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */) {
    return;
  }
  void getTabletStats(std::vector<TabletStats> & /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* tableId */) {
    return;
  }
  void getHistoricalStats(TabletStats& /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */) {
    return;
  }
  void halt(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */) {
    return;
  }
  void fastHalt(const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */, const std::string& /* lock */) {
    return;
  }
  void getActiveScans(std::vector<ActiveScan> & /* _return */, const accumulo::cloudtrace::TInfo& /* tinfo */, const accumulo::security::AuthInfo& /* credentials */) {
    return;
  }
};

typedef struct _TabletClientService_startScan_args__isset {
  _TabletClientService_startScan_args__isset() : tinfo(false), credentials(false), extent(false), range(false), columns(false), batchSize(false), ssiList(false), ssio(false), authorizations(false), waitForWrites(false), isolated(false) {}
  bool tinfo;
  bool credentials;
  bool extent;
  bool range;
  bool columns;
  bool batchSize;
  bool ssiList;
  bool ssio;
  bool authorizations;
  bool waitForWrites;
  bool isolated;
} _TabletClientService_startScan_args__isset;

class TabletClientService_startScan_args {
 public:

  TabletClientService_startScan_args() : batchSize(0), waitForWrites(0), isolated(0) {
  }

  virtual ~TabletClientService_startScan_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  accumulo::data::TKeyExtent extent;
  accumulo::data::TRange range;
  std::vector<accumulo::data::TColumn>  columns;
  int32_t batchSize;
  std::vector<accumulo::data::IterInfo>  ssiList;
  std::map<std::string, std::map<std::string, std::string> >  ssio;
  std::vector<std::string>  authorizations;
  bool waitForWrites;
  bool isolated;

  _TabletClientService_startScan_args__isset __isset;

  bool operator == (const TabletClientService_startScan_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(extent == rhs.extent))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(batchSize == rhs.batchSize))
      return false;
    if (!(ssiList == rhs.ssiList))
      return false;
    if (!(ssio == rhs.ssio))
      return false;
    if (!(authorizations == rhs.authorizations))
      return false;
    if (!(waitForWrites == rhs.waitForWrites))
      return false;
    if (!(isolated == rhs.isolated))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_startScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_startScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_startScan_pargs {
 public:


  virtual ~TabletClientService_startScan_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const accumulo::data::TKeyExtent* extent;
  const accumulo::data::TRange* range;
  const std::vector<accumulo::data::TColumn> * columns;
  const int32_t* batchSize;
  const std::vector<accumulo::data::IterInfo> * ssiList;
  const std::map<std::string, std::map<std::string, std::string> > * ssio;
  const std::vector<std::string> * authorizations;
  const bool* waitForWrites;
  const bool* isolated;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_startScan_result__isset {
  _TabletClientService_startScan_result__isset() : success(false), sec(false), nste(false), tmfe(false) {}
  bool success;
  bool sec;
  bool nste;
  bool tmfe;
} _TabletClientService_startScan_result__isset;

class TabletClientService_startScan_result {
 public:

  TabletClientService_startScan_result() {
  }

  virtual ~TabletClientService_startScan_result() throw() {}

  accumulo::data::InitialScan success;
  accumulo::security::ThriftSecurityException sec;
  NotServingTabletException nste;
  TooManyFilesException tmfe;

  _TabletClientService_startScan_result__isset __isset;

  bool operator == (const TabletClientService_startScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    if (!(nste == rhs.nste))
      return false;
    if (!(tmfe == rhs.tmfe))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_startScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_startScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_startScan_presult__isset {
  _TabletClientService_startScan_presult__isset() : success(false), sec(false), nste(false), tmfe(false) {}
  bool success;
  bool sec;
  bool nste;
  bool tmfe;
} _TabletClientService_startScan_presult__isset;

class TabletClientService_startScan_presult {
 public:


  virtual ~TabletClientService_startScan_presult() throw() {}

  accumulo::data::InitialScan* success;
  accumulo::security::ThriftSecurityException sec;
  NotServingTabletException nste;
  TooManyFilesException tmfe;

  _TabletClientService_startScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_continueScan_args__isset {
  _TabletClientService_continueScan_args__isset() : tinfo(false), scanID(false) {}
  bool tinfo;
  bool scanID;
} _TabletClientService_continueScan_args__isset;

class TabletClientService_continueScan_args {
 public:

  TabletClientService_continueScan_args() : scanID(0) {
  }

  virtual ~TabletClientService_continueScan_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::data::ScanID scanID;

  _TabletClientService_continueScan_args__isset __isset;

  bool operator == (const TabletClientService_continueScan_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(scanID == rhs.scanID))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_continueScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_continueScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_continueScan_pargs {
 public:


  virtual ~TabletClientService_continueScan_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::data::ScanID* scanID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_continueScan_result__isset {
  _TabletClientService_continueScan_result__isset() : success(false), nssi(false), nste(false), tmfe(false) {}
  bool success;
  bool nssi;
  bool nste;
  bool tmfe;
} _TabletClientService_continueScan_result__isset;

class TabletClientService_continueScan_result {
 public:

  TabletClientService_continueScan_result() {
  }

  virtual ~TabletClientService_continueScan_result() throw() {}

  accumulo::data::ScanResult success;
  NoSuchScanIDException nssi;
  NotServingTabletException nste;
  TooManyFilesException tmfe;

  _TabletClientService_continueScan_result__isset __isset;

  bool operator == (const TabletClientService_continueScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(nssi == rhs.nssi))
      return false;
    if (!(nste == rhs.nste))
      return false;
    if (!(tmfe == rhs.tmfe))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_continueScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_continueScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_continueScan_presult__isset {
  _TabletClientService_continueScan_presult__isset() : success(false), nssi(false), nste(false), tmfe(false) {}
  bool success;
  bool nssi;
  bool nste;
  bool tmfe;
} _TabletClientService_continueScan_presult__isset;

class TabletClientService_continueScan_presult {
 public:


  virtual ~TabletClientService_continueScan_presult() throw() {}

  accumulo::data::ScanResult* success;
  NoSuchScanIDException nssi;
  NotServingTabletException nste;
  TooManyFilesException tmfe;

  _TabletClientService_continueScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_closeScan_args__isset {
  _TabletClientService_closeScan_args__isset() : tinfo(false), scanID(false) {}
  bool tinfo;
  bool scanID;
} _TabletClientService_closeScan_args__isset;

class TabletClientService_closeScan_args {
 public:

  TabletClientService_closeScan_args() : scanID(0) {
  }

  virtual ~TabletClientService_closeScan_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::data::ScanID scanID;

  _TabletClientService_closeScan_args__isset __isset;

  bool operator == (const TabletClientService_closeScan_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(scanID == rhs.scanID))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_closeScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_closeScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_closeScan_pargs {
 public:


  virtual ~TabletClientService_closeScan_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::data::ScanID* scanID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_startMultiScan_args__isset {
  _TabletClientService_startMultiScan_args__isset() : tinfo(false), credentials(false), batch(false), columns(false), ssiList(false), ssio(false), authorizations(false), waitForWrites(false) {}
  bool tinfo;
  bool credentials;
  bool batch;
  bool columns;
  bool ssiList;
  bool ssio;
  bool authorizations;
  bool waitForWrites;
} _TabletClientService_startMultiScan_args__isset;

class TabletClientService_startMultiScan_args {
 public:

  TabletClientService_startMultiScan_args() : waitForWrites(0) {
  }

  virtual ~TabletClientService_startMultiScan_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  accumulo::data::ScanBatch batch;
  std::vector<accumulo::data::TColumn>  columns;
  std::vector<accumulo::data::IterInfo>  ssiList;
  std::map<std::string, std::map<std::string, std::string> >  ssio;
  std::vector<std::string>  authorizations;
  bool waitForWrites;

  _TabletClientService_startMultiScan_args__isset __isset;

  bool operator == (const TabletClientService_startMultiScan_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(batch == rhs.batch))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(ssiList == rhs.ssiList))
      return false;
    if (!(ssio == rhs.ssio))
      return false;
    if (!(authorizations == rhs.authorizations))
      return false;
    if (!(waitForWrites == rhs.waitForWrites))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_startMultiScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_startMultiScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_startMultiScan_pargs {
 public:


  virtual ~TabletClientService_startMultiScan_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const accumulo::data::ScanBatch* batch;
  const std::vector<accumulo::data::TColumn> * columns;
  const std::vector<accumulo::data::IterInfo> * ssiList;
  const std::map<std::string, std::map<std::string, std::string> > * ssio;
  const std::vector<std::string> * authorizations;
  const bool* waitForWrites;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_startMultiScan_result__isset {
  _TabletClientService_startMultiScan_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_startMultiScan_result__isset;

class TabletClientService_startMultiScan_result {
 public:

  TabletClientService_startMultiScan_result() {
  }

  virtual ~TabletClientService_startMultiScan_result() throw() {}

  accumulo::data::InitialMultiScan success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_startMultiScan_result__isset __isset;

  bool operator == (const TabletClientService_startMultiScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_startMultiScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_startMultiScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_startMultiScan_presult__isset {
  _TabletClientService_startMultiScan_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_startMultiScan_presult__isset;

class TabletClientService_startMultiScan_presult {
 public:


  virtual ~TabletClientService_startMultiScan_presult() throw() {}

  accumulo::data::InitialMultiScan* success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_startMultiScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_continueMultiScan_args__isset {
  _TabletClientService_continueMultiScan_args__isset() : tinfo(false), scanID(false) {}
  bool tinfo;
  bool scanID;
} _TabletClientService_continueMultiScan_args__isset;

class TabletClientService_continueMultiScan_args {
 public:

  TabletClientService_continueMultiScan_args() : scanID(0) {
  }

  virtual ~TabletClientService_continueMultiScan_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::data::ScanID scanID;

  _TabletClientService_continueMultiScan_args__isset __isset;

  bool operator == (const TabletClientService_continueMultiScan_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(scanID == rhs.scanID))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_continueMultiScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_continueMultiScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_continueMultiScan_pargs {
 public:


  virtual ~TabletClientService_continueMultiScan_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::data::ScanID* scanID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_continueMultiScan_result__isset {
  _TabletClientService_continueMultiScan_result__isset() : success(false), nssi(false) {}
  bool success;
  bool nssi;
} _TabletClientService_continueMultiScan_result__isset;

class TabletClientService_continueMultiScan_result {
 public:

  TabletClientService_continueMultiScan_result() {
  }

  virtual ~TabletClientService_continueMultiScan_result() throw() {}

  accumulo::data::MultiScanResult success;
  NoSuchScanIDException nssi;

  _TabletClientService_continueMultiScan_result__isset __isset;

  bool operator == (const TabletClientService_continueMultiScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(nssi == rhs.nssi))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_continueMultiScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_continueMultiScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_continueMultiScan_presult__isset {
  _TabletClientService_continueMultiScan_presult__isset() : success(false), nssi(false) {}
  bool success;
  bool nssi;
} _TabletClientService_continueMultiScan_presult__isset;

class TabletClientService_continueMultiScan_presult {
 public:


  virtual ~TabletClientService_continueMultiScan_presult() throw() {}

  accumulo::data::MultiScanResult* success;
  NoSuchScanIDException nssi;

  _TabletClientService_continueMultiScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_closeMultiScan_args__isset {
  _TabletClientService_closeMultiScan_args__isset() : tinfo(false), scanID(false) {}
  bool tinfo;
  bool scanID;
} _TabletClientService_closeMultiScan_args__isset;

class TabletClientService_closeMultiScan_args {
 public:

  TabletClientService_closeMultiScan_args() : scanID(0) {
  }

  virtual ~TabletClientService_closeMultiScan_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::data::ScanID scanID;

  _TabletClientService_closeMultiScan_args__isset __isset;

  bool operator == (const TabletClientService_closeMultiScan_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(scanID == rhs.scanID))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_closeMultiScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_closeMultiScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_closeMultiScan_pargs {
 public:


  virtual ~TabletClientService_closeMultiScan_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::data::ScanID* scanID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_closeMultiScan_result__isset {
  _TabletClientService_closeMultiScan_result__isset() : nssi(false) {}
  bool nssi;
} _TabletClientService_closeMultiScan_result__isset;

class TabletClientService_closeMultiScan_result {
 public:

  TabletClientService_closeMultiScan_result() {
  }

  virtual ~TabletClientService_closeMultiScan_result() throw() {}

  NoSuchScanIDException nssi;

  _TabletClientService_closeMultiScan_result__isset __isset;

  bool operator == (const TabletClientService_closeMultiScan_result & rhs) const
  {
    if (!(nssi == rhs.nssi))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_closeMultiScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_closeMultiScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_closeMultiScan_presult__isset {
  _TabletClientService_closeMultiScan_presult__isset() : nssi(false) {}
  bool nssi;
} _TabletClientService_closeMultiScan_presult__isset;

class TabletClientService_closeMultiScan_presult {
 public:


  virtual ~TabletClientService_closeMultiScan_presult() throw() {}

  NoSuchScanIDException nssi;

  _TabletClientService_closeMultiScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_startUpdate_args__isset {
  _TabletClientService_startUpdate_args__isset() : tinfo(false), credentials(false) {}
  bool tinfo;
  bool credentials;
} _TabletClientService_startUpdate_args__isset;

class TabletClientService_startUpdate_args {
 public:

  TabletClientService_startUpdate_args() {
  }

  virtual ~TabletClientService_startUpdate_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;

  _TabletClientService_startUpdate_args__isset __isset;

  bool operator == (const TabletClientService_startUpdate_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_startUpdate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_startUpdate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_startUpdate_pargs {
 public:


  virtual ~TabletClientService_startUpdate_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_startUpdate_result__isset {
  _TabletClientService_startUpdate_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_startUpdate_result__isset;

class TabletClientService_startUpdate_result {
 public:

  TabletClientService_startUpdate_result() : success(0) {
  }

  virtual ~TabletClientService_startUpdate_result() throw() {}

  accumulo::data::UpdateID success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_startUpdate_result__isset __isset;

  bool operator == (const TabletClientService_startUpdate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_startUpdate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_startUpdate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_startUpdate_presult__isset {
  _TabletClientService_startUpdate_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_startUpdate_presult__isset;

class TabletClientService_startUpdate_presult {
 public:


  virtual ~TabletClientService_startUpdate_presult() throw() {}

  accumulo::data::UpdateID* success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_startUpdate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_applyUpdates_args__isset {
  _TabletClientService_applyUpdates_args__isset() : tinfo(false), updateID(false), keyExtent(false), mutations(false) {}
  bool tinfo;
  bool updateID;
  bool keyExtent;
  bool mutations;
} _TabletClientService_applyUpdates_args__isset;

class TabletClientService_applyUpdates_args {
 public:

  TabletClientService_applyUpdates_args() : updateID(0) {
  }

  virtual ~TabletClientService_applyUpdates_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::data::UpdateID updateID;
  accumulo::data::TKeyExtent keyExtent;
  std::vector<accumulo::data::TMutation>  mutations;

  _TabletClientService_applyUpdates_args__isset __isset;

  bool operator == (const TabletClientService_applyUpdates_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(updateID == rhs.updateID))
      return false;
    if (!(keyExtent == rhs.keyExtent))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_applyUpdates_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_applyUpdates_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_applyUpdates_pargs {
 public:


  virtual ~TabletClientService_applyUpdates_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::data::UpdateID* updateID;
  const accumulo::data::TKeyExtent* keyExtent;
  const std::vector<accumulo::data::TMutation> * mutations;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_closeUpdate_args__isset {
  _TabletClientService_closeUpdate_args__isset() : tinfo(false), updateID(false) {}
  bool tinfo;
  bool updateID;
} _TabletClientService_closeUpdate_args__isset;

class TabletClientService_closeUpdate_args {
 public:

  TabletClientService_closeUpdate_args() : updateID(0) {
  }

  virtual ~TabletClientService_closeUpdate_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::data::UpdateID updateID;

  _TabletClientService_closeUpdate_args__isset __isset;

  bool operator == (const TabletClientService_closeUpdate_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(updateID == rhs.updateID))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_closeUpdate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_closeUpdate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_closeUpdate_pargs {
 public:


  virtual ~TabletClientService_closeUpdate_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::data::UpdateID* updateID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_closeUpdate_result__isset {
  _TabletClientService_closeUpdate_result__isset() : success(false), nssi(false) {}
  bool success;
  bool nssi;
} _TabletClientService_closeUpdate_result__isset;

class TabletClientService_closeUpdate_result {
 public:

  TabletClientService_closeUpdate_result() {
  }

  virtual ~TabletClientService_closeUpdate_result() throw() {}

  accumulo::data::UpdateErrors success;
  NoSuchScanIDException nssi;

  _TabletClientService_closeUpdate_result__isset __isset;

  bool operator == (const TabletClientService_closeUpdate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(nssi == rhs.nssi))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_closeUpdate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_closeUpdate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_closeUpdate_presult__isset {
  _TabletClientService_closeUpdate_presult__isset() : success(false), nssi(false) {}
  bool success;
  bool nssi;
} _TabletClientService_closeUpdate_presult__isset;

class TabletClientService_closeUpdate_presult {
 public:


  virtual ~TabletClientService_closeUpdate_presult() throw() {}

  accumulo::data::UpdateErrors* success;
  NoSuchScanIDException nssi;

  _TabletClientService_closeUpdate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_update_args__isset {
  _TabletClientService_update_args__isset() : tinfo(false), credentials(false), keyExtent(false), mutation(false) {}
  bool tinfo;
  bool credentials;
  bool keyExtent;
  bool mutation;
} _TabletClientService_update_args__isset;

class TabletClientService_update_args {
 public:

  TabletClientService_update_args() {
  }

  virtual ~TabletClientService_update_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  accumulo::data::TKeyExtent keyExtent;
  accumulo::data::TMutation mutation;

  _TabletClientService_update_args__isset __isset;

  bool operator == (const TabletClientService_update_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(keyExtent == rhs.keyExtent))
      return false;
    if (!(mutation == rhs.mutation))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_update_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_update_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_update_pargs {
 public:


  virtual ~TabletClientService_update_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const accumulo::data::TKeyExtent* keyExtent;
  const accumulo::data::TMutation* mutation;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_update_result__isset {
  _TabletClientService_update_result__isset() : sec(false), nste(false), cve(false) {}
  bool sec;
  bool nste;
  bool cve;
} _TabletClientService_update_result__isset;

class TabletClientService_update_result {
 public:

  TabletClientService_update_result() {
  }

  virtual ~TabletClientService_update_result() throw() {}

  accumulo::security::ThriftSecurityException sec;
  NotServingTabletException nste;
  ConstraintViolationException cve;

  _TabletClientService_update_result__isset __isset;

  bool operator == (const TabletClientService_update_result & rhs) const
  {
    if (!(sec == rhs.sec))
      return false;
    if (!(nste == rhs.nste))
      return false;
    if (!(cve == rhs.cve))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_update_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_update_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_update_presult__isset {
  _TabletClientService_update_presult__isset() : sec(false), nste(false), cve(false) {}
  bool sec;
  bool nste;
  bool cve;
} _TabletClientService_update_presult__isset;

class TabletClientService_update_presult {
 public:


  virtual ~TabletClientService_update_presult() throw() {}

  accumulo::security::ThriftSecurityException sec;
  NotServingTabletException nste;
  ConstraintViolationException cve;

  _TabletClientService_update_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_bulkImport_args__isset {
  _TabletClientService_bulkImport_args__isset() : tinfo(false), credentials(false), tid(false), files(false), setTime(false) {}
  bool tinfo;
  bool credentials;
  bool tid;
  bool files;
  bool setTime;
} _TabletClientService_bulkImport_args__isset;

class TabletClientService_bulkImport_args {
 public:

  TabletClientService_bulkImport_args() : tid(0), setTime(0) {
  }

  virtual ~TabletClientService_bulkImport_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  int64_t tid;
  accumulo::data::TabletFiles files;
  bool setTime;

  _TabletClientService_bulkImport_args__isset __isset;

  bool operator == (const TabletClientService_bulkImport_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(tid == rhs.tid))
      return false;
    if (!(files == rhs.files))
      return false;
    if (!(setTime == rhs.setTime))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_bulkImport_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_bulkImport_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_bulkImport_pargs {
 public:


  virtual ~TabletClientService_bulkImport_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const int64_t* tid;
  const accumulo::data::TabletFiles* files;
  const bool* setTime;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_bulkImport_result__isset {
  _TabletClientService_bulkImport_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_bulkImport_result__isset;

class TabletClientService_bulkImport_result {
 public:

  TabletClientService_bulkImport_result() {
  }

  virtual ~TabletClientService_bulkImport_result() throw() {}

  std::vector<accumulo::data::TKeyExtent>  success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_bulkImport_result__isset __isset;

  bool operator == (const TabletClientService_bulkImport_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_bulkImport_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_bulkImport_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_bulkImport_presult__isset {
  _TabletClientService_bulkImport_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_bulkImport_presult__isset;

class TabletClientService_bulkImport_presult {
 public:


  virtual ~TabletClientService_bulkImport_presult() throw() {}

  std::vector<accumulo::data::TKeyExtent> * success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_bulkImport_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_splitTablet_args__isset {
  _TabletClientService_splitTablet_args__isset() : tinfo(false), credentials(false), extent(false), splitPoint(false) {}
  bool tinfo;
  bool credentials;
  bool extent;
  bool splitPoint;
} _TabletClientService_splitTablet_args__isset;

class TabletClientService_splitTablet_args {
 public:

  TabletClientService_splitTablet_args() : splitPoint("") {
  }

  virtual ~TabletClientService_splitTablet_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  accumulo::data::TKeyExtent extent;
  std::string splitPoint;

  _TabletClientService_splitTablet_args__isset __isset;

  bool operator == (const TabletClientService_splitTablet_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(extent == rhs.extent))
      return false;
    if (!(splitPoint == rhs.splitPoint))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_splitTablet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_splitTablet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_splitTablet_pargs {
 public:


  virtual ~TabletClientService_splitTablet_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const accumulo::data::TKeyExtent* extent;
  const std::string* splitPoint;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_splitTablet_result__isset {
  _TabletClientService_splitTablet_result__isset() : sec(false), nste(false) {}
  bool sec;
  bool nste;
} _TabletClientService_splitTablet_result__isset;

class TabletClientService_splitTablet_result {
 public:

  TabletClientService_splitTablet_result() {
  }

  virtual ~TabletClientService_splitTablet_result() throw() {}

  accumulo::security::ThriftSecurityException sec;
  NotServingTabletException nste;

  _TabletClientService_splitTablet_result__isset __isset;

  bool operator == (const TabletClientService_splitTablet_result & rhs) const
  {
    if (!(sec == rhs.sec))
      return false;
    if (!(nste == rhs.nste))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_splitTablet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_splitTablet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_splitTablet_presult__isset {
  _TabletClientService_splitTablet_presult__isset() : sec(false), nste(false) {}
  bool sec;
  bool nste;
} _TabletClientService_splitTablet_presult__isset;

class TabletClientService_splitTablet_presult {
 public:


  virtual ~TabletClientService_splitTablet_presult() throw() {}

  accumulo::security::ThriftSecurityException sec;
  NotServingTabletException nste;

  _TabletClientService_splitTablet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_loadTablet_args__isset {
  _TabletClientService_loadTablet_args__isset() : tinfo(false), credentials(false), lock(false), extent(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
  bool extent;
} _TabletClientService_loadTablet_args__isset;

class TabletClientService_loadTablet_args {
 public:

  TabletClientService_loadTablet_args() : lock("") {
  }

  virtual ~TabletClientService_loadTablet_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;
  accumulo::data::TKeyExtent extent;

  _TabletClientService_loadTablet_args__isset __isset;

  bool operator == (const TabletClientService_loadTablet_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    if (!(extent == rhs.extent))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_loadTablet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_loadTablet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_loadTablet_pargs {
 public:


  virtual ~TabletClientService_loadTablet_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;
  const accumulo::data::TKeyExtent* extent;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_unloadTablet_args__isset {
  _TabletClientService_unloadTablet_args__isset() : tinfo(false), credentials(false), lock(false), extent(false), save(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
  bool extent;
  bool save;
} _TabletClientService_unloadTablet_args__isset;

class TabletClientService_unloadTablet_args {
 public:

  TabletClientService_unloadTablet_args() : lock(""), save(0) {
  }

  virtual ~TabletClientService_unloadTablet_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;
  accumulo::data::TKeyExtent extent;
  bool save;

  _TabletClientService_unloadTablet_args__isset __isset;

  bool operator == (const TabletClientService_unloadTablet_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    if (!(extent == rhs.extent))
      return false;
    if (!(save == rhs.save))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_unloadTablet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_unloadTablet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_unloadTablet_pargs {
 public:


  virtual ~TabletClientService_unloadTablet_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;
  const accumulo::data::TKeyExtent* extent;
  const bool* save;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_flush_args__isset {
  _TabletClientService_flush_args__isset() : tinfo(false), credentials(false), lock(false), tableId(false), startRow(false), endRow(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
  bool tableId;
  bool startRow;
  bool endRow;
} _TabletClientService_flush_args__isset;

class TabletClientService_flush_args {
 public:

  TabletClientService_flush_args() : lock(""), tableId(""), startRow(""), endRow("") {
  }

  virtual ~TabletClientService_flush_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;
  std::string tableId;
  std::string startRow;
  std::string endRow;

  _TabletClientService_flush_args__isset __isset;

  bool operator == (const TabletClientService_flush_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    if (!(tableId == rhs.tableId))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(endRow == rhs.endRow))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_flush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_flush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_flush_pargs {
 public:


  virtual ~TabletClientService_flush_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;
  const std::string* tableId;
  const std::string* startRow;
  const std::string* endRow;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_flushTablet_args__isset {
  _TabletClientService_flushTablet_args__isset() : tinfo(false), credentials(false), lock(false), extent(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
  bool extent;
} _TabletClientService_flushTablet_args__isset;

class TabletClientService_flushTablet_args {
 public:

  TabletClientService_flushTablet_args() : lock("") {
  }

  virtual ~TabletClientService_flushTablet_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;
  accumulo::data::TKeyExtent extent;

  _TabletClientService_flushTablet_args__isset __isset;

  bool operator == (const TabletClientService_flushTablet_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    if (!(extent == rhs.extent))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_flushTablet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_flushTablet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_flushTablet_pargs {
 public:


  virtual ~TabletClientService_flushTablet_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;
  const accumulo::data::TKeyExtent* extent;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_chop_args__isset {
  _TabletClientService_chop_args__isset() : tinfo(false), credentials(false), lock(false), extent(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
  bool extent;
} _TabletClientService_chop_args__isset;

class TabletClientService_chop_args {
 public:

  TabletClientService_chop_args() : lock("") {
  }

  virtual ~TabletClientService_chop_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;
  accumulo::data::TKeyExtent extent;

  _TabletClientService_chop_args__isset __isset;

  bool operator == (const TabletClientService_chop_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    if (!(extent == rhs.extent))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_chop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_chop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_chop_pargs {
 public:


  virtual ~TabletClientService_chop_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;
  const accumulo::data::TKeyExtent* extent;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_compact_args__isset {
  _TabletClientService_compact_args__isset() : tinfo(false), credentials(false), lock(false), tableId(false), startRow(false), endRow(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
  bool tableId;
  bool startRow;
  bool endRow;
} _TabletClientService_compact_args__isset;

class TabletClientService_compact_args {
 public:

  TabletClientService_compact_args() : lock(""), tableId(""), startRow(""), endRow("") {
  }

  virtual ~TabletClientService_compact_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;
  std::string tableId;
  std::string startRow;
  std::string endRow;

  _TabletClientService_compact_args__isset __isset;

  bool operator == (const TabletClientService_compact_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    if (!(tableId == rhs.tableId))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(endRow == rhs.endRow))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_compact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_compact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_compact_pargs {
 public:


  virtual ~TabletClientService_compact_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;
  const std::string* tableId;
  const std::string* startRow;
  const std::string* endRow;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_useLoggers_args__isset {
  _TabletClientService_useLoggers_args__isset() : tinfo(false), credentials(false), loggers(false) {}
  bool tinfo;
  bool credentials;
  bool loggers;
} _TabletClientService_useLoggers_args__isset;

class TabletClientService_useLoggers_args {
 public:

  TabletClientService_useLoggers_args() {
  }

  virtual ~TabletClientService_useLoggers_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::set<std::string>  loggers;

  _TabletClientService_useLoggers_args__isset __isset;

  bool operator == (const TabletClientService_useLoggers_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(loggers == rhs.loggers))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_useLoggers_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_useLoggers_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_useLoggers_pargs {
 public:


  virtual ~TabletClientService_useLoggers_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::set<std::string> * loggers;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getTabletServerStatus_args__isset {
  _TabletClientService_getTabletServerStatus_args__isset() : tinfo(false), credentials(false) {}
  bool tinfo;
  bool credentials;
} _TabletClientService_getTabletServerStatus_args__isset;

class TabletClientService_getTabletServerStatus_args {
 public:

  TabletClientService_getTabletServerStatus_args() {
  }

  virtual ~TabletClientService_getTabletServerStatus_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;

  _TabletClientService_getTabletServerStatus_args__isset __isset;

  bool operator == (const TabletClientService_getTabletServerStatus_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getTabletServerStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getTabletServerStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_getTabletServerStatus_pargs {
 public:


  virtual ~TabletClientService_getTabletServerStatus_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getTabletServerStatus_result__isset {
  _TabletClientService_getTabletServerStatus_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getTabletServerStatus_result__isset;

class TabletClientService_getTabletServerStatus_result {
 public:

  TabletClientService_getTabletServerStatus_result() {
  }

  virtual ~TabletClientService_getTabletServerStatus_result() throw() {}

  accumulo::master::TabletServerStatus success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getTabletServerStatus_result__isset __isset;

  bool operator == (const TabletClientService_getTabletServerStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getTabletServerStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getTabletServerStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getTabletServerStatus_presult__isset {
  _TabletClientService_getTabletServerStatus_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getTabletServerStatus_presult__isset;

class TabletClientService_getTabletServerStatus_presult {
 public:


  virtual ~TabletClientService_getTabletServerStatus_presult() throw() {}

  accumulo::master::TabletServerStatus* success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getTabletServerStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_getTabletStats_args__isset {
  _TabletClientService_getTabletStats_args__isset() : tinfo(false), credentials(false), tableId(false) {}
  bool tinfo;
  bool credentials;
  bool tableId;
} _TabletClientService_getTabletStats_args__isset;

class TabletClientService_getTabletStats_args {
 public:

  TabletClientService_getTabletStats_args() : tableId("") {
  }

  virtual ~TabletClientService_getTabletStats_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string tableId;

  _TabletClientService_getTabletStats_args__isset __isset;

  bool operator == (const TabletClientService_getTabletStats_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getTabletStats_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getTabletStats_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_getTabletStats_pargs {
 public:


  virtual ~TabletClientService_getTabletStats_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* tableId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getTabletStats_result__isset {
  _TabletClientService_getTabletStats_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getTabletStats_result__isset;

class TabletClientService_getTabletStats_result {
 public:

  TabletClientService_getTabletStats_result() {
  }

  virtual ~TabletClientService_getTabletStats_result() throw() {}

  std::vector<TabletStats>  success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getTabletStats_result__isset __isset;

  bool operator == (const TabletClientService_getTabletStats_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getTabletStats_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getTabletStats_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getTabletStats_presult__isset {
  _TabletClientService_getTabletStats_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getTabletStats_presult__isset;

class TabletClientService_getTabletStats_presult {
 public:


  virtual ~TabletClientService_getTabletStats_presult() throw() {}

  std::vector<TabletStats> * success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getTabletStats_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_getHistoricalStats_args__isset {
  _TabletClientService_getHistoricalStats_args__isset() : tinfo(false), credentials(false) {}
  bool tinfo;
  bool credentials;
} _TabletClientService_getHistoricalStats_args__isset;

class TabletClientService_getHistoricalStats_args {
 public:

  TabletClientService_getHistoricalStats_args() {
  }

  virtual ~TabletClientService_getHistoricalStats_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;

  _TabletClientService_getHistoricalStats_args__isset __isset;

  bool operator == (const TabletClientService_getHistoricalStats_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getHistoricalStats_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getHistoricalStats_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_getHistoricalStats_pargs {
 public:


  virtual ~TabletClientService_getHistoricalStats_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getHistoricalStats_result__isset {
  _TabletClientService_getHistoricalStats_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getHistoricalStats_result__isset;

class TabletClientService_getHistoricalStats_result {
 public:

  TabletClientService_getHistoricalStats_result() {
  }

  virtual ~TabletClientService_getHistoricalStats_result() throw() {}

  TabletStats success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getHistoricalStats_result__isset __isset;

  bool operator == (const TabletClientService_getHistoricalStats_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getHistoricalStats_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getHistoricalStats_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getHistoricalStats_presult__isset {
  _TabletClientService_getHistoricalStats_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getHistoricalStats_presult__isset;

class TabletClientService_getHistoricalStats_presult {
 public:


  virtual ~TabletClientService_getHistoricalStats_presult() throw() {}

  TabletStats* success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getHistoricalStats_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_halt_args__isset {
  _TabletClientService_halt_args__isset() : tinfo(false), credentials(false), lock(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
} _TabletClientService_halt_args__isset;

class TabletClientService_halt_args {
 public:

  TabletClientService_halt_args() : lock("") {
  }

  virtual ~TabletClientService_halt_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;

  _TabletClientService_halt_args__isset __isset;

  bool operator == (const TabletClientService_halt_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_halt_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_halt_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_halt_pargs {
 public:


  virtual ~TabletClientService_halt_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_halt_result__isset {
  _TabletClientService_halt_result__isset() : sec(false) {}
  bool sec;
} _TabletClientService_halt_result__isset;

class TabletClientService_halt_result {
 public:

  TabletClientService_halt_result() {
  }

  virtual ~TabletClientService_halt_result() throw() {}

  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_halt_result__isset __isset;

  bool operator == (const TabletClientService_halt_result & rhs) const
  {
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_halt_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_halt_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_halt_presult__isset {
  _TabletClientService_halt_presult__isset() : sec(false) {}
  bool sec;
} _TabletClientService_halt_presult__isset;

class TabletClientService_halt_presult {
 public:


  virtual ~TabletClientService_halt_presult() throw() {}

  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_halt_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TabletClientService_fastHalt_args__isset {
  _TabletClientService_fastHalt_args__isset() : tinfo(false), credentials(false), lock(false) {}
  bool tinfo;
  bool credentials;
  bool lock;
} _TabletClientService_fastHalt_args__isset;

class TabletClientService_fastHalt_args {
 public:

  TabletClientService_fastHalt_args() : lock("") {
  }

  virtual ~TabletClientService_fastHalt_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;
  std::string lock;

  _TabletClientService_fastHalt_args__isset __isset;

  bool operator == (const TabletClientService_fastHalt_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    if (!(lock == rhs.lock))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_fastHalt_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_fastHalt_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_fastHalt_pargs {
 public:


  virtual ~TabletClientService_fastHalt_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;
  const std::string* lock;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getActiveScans_args__isset {
  _TabletClientService_getActiveScans_args__isset() : tinfo(false), credentials(false) {}
  bool tinfo;
  bool credentials;
} _TabletClientService_getActiveScans_args__isset;

class TabletClientService_getActiveScans_args {
 public:

  TabletClientService_getActiveScans_args() {
  }

  virtual ~TabletClientService_getActiveScans_args() throw() {}

  accumulo::cloudtrace::TInfo tinfo;
  accumulo::security::AuthInfo credentials;

  _TabletClientService_getActiveScans_args__isset __isset;

  bool operator == (const TabletClientService_getActiveScans_args & rhs) const
  {
    if (!(tinfo == rhs.tinfo))
      return false;
    if (!(credentials == rhs.credentials))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getActiveScans_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getActiveScans_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TabletClientService_getActiveScans_pargs {
 public:


  virtual ~TabletClientService_getActiveScans_pargs() throw() {}

  const accumulo::cloudtrace::TInfo* tinfo;
  const accumulo::security::AuthInfo* credentials;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getActiveScans_result__isset {
  _TabletClientService_getActiveScans_result__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getActiveScans_result__isset;

class TabletClientService_getActiveScans_result {
 public:

  TabletClientService_getActiveScans_result() {
  }

  virtual ~TabletClientService_getActiveScans_result() throw() {}

  std::vector<ActiveScan>  success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getActiveScans_result__isset __isset;

  bool operator == (const TabletClientService_getActiveScans_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(sec == rhs.sec))
      return false;
    return true;
  }
  bool operator != (const TabletClientService_getActiveScans_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletClientService_getActiveScans_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TabletClientService_getActiveScans_presult__isset {
  _TabletClientService_getActiveScans_presult__isset() : success(false), sec(false) {}
  bool success;
  bool sec;
} _TabletClientService_getActiveScans_presult__isset;

class TabletClientService_getActiveScans_presult {
 public:


  virtual ~TabletClientService_getActiveScans_presult() throw() {}

  std::vector<ActiveScan> * success;
  accumulo::security::ThriftSecurityException sec;

  _TabletClientService_getActiveScans_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class TabletClientServiceClient : virtual public TabletClientServiceIf, public accumulo::client::ClientServiceClient {
 public:
  TabletClientServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    accumulo::client::ClientServiceClient(prot, prot) {}
  TabletClientServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    accumulo::client::ClientServiceClient(iprot, oprot) {}
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void startScan(accumulo::data::InitialScan& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const accumulo::data::TRange& range, const std::vector<accumulo::data::TColumn> & columns, const int32_t batchSize, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated);
  void send_startScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const accumulo::data::TRange& range, const std::vector<accumulo::data::TColumn> & columns, const int32_t batchSize, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated);
  void recv_startScan(accumulo::data::InitialScan& _return);
  void continueScan(accumulo::data::ScanResult& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void send_continueScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void recv_continueScan(accumulo::data::ScanResult& _return);
  void closeScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void send_closeScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void startMultiScan(accumulo::data::InitialMultiScan& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::ScanBatch& batch, const std::vector<accumulo::data::TColumn> & columns, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites);
  void send_startMultiScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::ScanBatch& batch, const std::vector<accumulo::data::TColumn> & columns, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites);
  void recv_startMultiScan(accumulo::data::InitialMultiScan& _return);
  void continueMultiScan(accumulo::data::MultiScanResult& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void send_continueMultiScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void recv_continueMultiScan(accumulo::data::MultiScanResult& _return);
  void closeMultiScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void send_closeMultiScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID);
  void recv_closeMultiScan();
  accumulo::data::UpdateID startUpdate(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void send_startUpdate(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  accumulo::data::UpdateID recv_startUpdate();
  void applyUpdates(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID, const accumulo::data::TKeyExtent& keyExtent, const std::vector<accumulo::data::TMutation> & mutations);
  void send_applyUpdates(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID, const accumulo::data::TKeyExtent& keyExtent, const std::vector<accumulo::data::TMutation> & mutations);
  void closeUpdate(accumulo::data::UpdateErrors& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID);
  void send_closeUpdate(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID);
  void recv_closeUpdate(accumulo::data::UpdateErrors& _return);
  void update(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& keyExtent, const accumulo::data::TMutation& mutation);
  void send_update(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& keyExtent, const accumulo::data::TMutation& mutation);
  void recv_update();
  void bulkImport(std::vector<accumulo::data::TKeyExtent> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const int64_t tid, const accumulo::data::TabletFiles& files, const bool setTime);
  void send_bulkImport(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const int64_t tid, const accumulo::data::TabletFiles& files, const bool setTime);
  void recv_bulkImport(std::vector<accumulo::data::TKeyExtent> & _return);
  void splitTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const std::string& splitPoint);
  void send_splitTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const std::string& splitPoint);
  void recv_splitTablet();
  void loadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent);
  void send_loadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent);
  void unloadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent, const bool save);
  void send_unloadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent, const bool save);
  void flush(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow);
  void send_flush(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow);
  void flushTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent);
  void send_flushTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent);
  void chop(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent);
  void send_chop(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent);
  void compact(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow);
  void send_compact(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow);
  void useLoggers(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::set<std::string> & loggers);
  void send_useLoggers(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::set<std::string> & loggers);
  void getTabletServerStatus(accumulo::master::TabletServerStatus& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void send_getTabletServerStatus(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void recv_getTabletServerStatus(accumulo::master::TabletServerStatus& _return);
  void getTabletStats(std::vector<TabletStats> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tableId);
  void send_getTabletStats(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tableId);
  void recv_getTabletStats(std::vector<TabletStats> & _return);
  void getHistoricalStats(TabletStats& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void send_getHistoricalStats(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void recv_getHistoricalStats(TabletStats& _return);
  void halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock);
  void send_halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock);
  void recv_halt();
  void fastHalt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock);
  void send_fastHalt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock);
  void getActiveScans(std::vector<ActiveScan> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void send_getActiveScans(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials);
  void recv_getActiveScans(std::vector<ActiveScan> & _return);
};

class TabletClientServiceProcessor : virtual public ::apache::thrift::TProcessor, public accumulo::client::ClientServiceProcessor {
 protected:
  boost::shared_ptr<TabletClientServiceIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (TabletClientServiceProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_startScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_continueScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_startMultiScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_continueMultiScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeMultiScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_startUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_applyUpdates(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_bulkImport(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_splitTablet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_loadTablet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unloadTablet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_flush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_flushTablet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_chop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compact(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_useLoggers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTabletServerStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTabletStats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getHistoricalStats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_halt(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_fastHalt(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getActiveScans(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  TabletClientServiceProcessor(boost::shared_ptr<TabletClientServiceIf> iface) :
    accumulo::client::ClientServiceProcessor(iface),
    iface_(iface) {
    processMap_["startScan"] = &TabletClientServiceProcessor::process_startScan;
    processMap_["continueScan"] = &TabletClientServiceProcessor::process_continueScan;
    processMap_["closeScan"] = &TabletClientServiceProcessor::process_closeScan;
    processMap_["startMultiScan"] = &TabletClientServiceProcessor::process_startMultiScan;
    processMap_["continueMultiScan"] = &TabletClientServiceProcessor::process_continueMultiScan;
    processMap_["closeMultiScan"] = &TabletClientServiceProcessor::process_closeMultiScan;
    processMap_["startUpdate"] = &TabletClientServiceProcessor::process_startUpdate;
    processMap_["applyUpdates"] = &TabletClientServiceProcessor::process_applyUpdates;
    processMap_["closeUpdate"] = &TabletClientServiceProcessor::process_closeUpdate;
    processMap_["update"] = &TabletClientServiceProcessor::process_update;
    processMap_["bulkImport"] = &TabletClientServiceProcessor::process_bulkImport;
    processMap_["splitTablet"] = &TabletClientServiceProcessor::process_splitTablet;
    processMap_["loadTablet"] = &TabletClientServiceProcessor::process_loadTablet;
    processMap_["unloadTablet"] = &TabletClientServiceProcessor::process_unloadTablet;
    processMap_["flush"] = &TabletClientServiceProcessor::process_flush;
    processMap_["flushTablet"] = &TabletClientServiceProcessor::process_flushTablet;
    processMap_["chop"] = &TabletClientServiceProcessor::process_chop;
    processMap_["compact"] = &TabletClientServiceProcessor::process_compact;
    processMap_["useLoggers"] = &TabletClientServiceProcessor::process_useLoggers;
    processMap_["getTabletServerStatus"] = &TabletClientServiceProcessor::process_getTabletServerStatus;
    processMap_["getTabletStats"] = &TabletClientServiceProcessor::process_getTabletStats;
    processMap_["getHistoricalStats"] = &TabletClientServiceProcessor::process_getHistoricalStats;
    processMap_["halt"] = &TabletClientServiceProcessor::process_halt;
    processMap_["fastHalt"] = &TabletClientServiceProcessor::process_fastHalt;
    processMap_["getActiveScans"] = &TabletClientServiceProcessor::process_getActiveScans;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~TabletClientServiceProcessor() {}
};

class TabletClientServiceMultiface : virtual public TabletClientServiceIf, public accumulo::client::ClientServiceMultiface {
 public:
  TabletClientServiceMultiface(std::vector<boost::shared_ptr<TabletClientServiceIf> >& ifaces) : ifaces_(ifaces) {
    std::vector<boost::shared_ptr<TabletClientServiceIf> >::iterator iter;
    for (iter = ifaces.begin(); iter != ifaces.end(); ++iter) {
      accumulo::client::ClientServiceMultiface::add(*iter);
    }
  }
  virtual ~TabletClientServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<TabletClientServiceIf> > ifaces_;
  TabletClientServiceMultiface() {}
  void add(boost::shared_ptr<TabletClientServiceIf> iface) {
    accumulo::client::ClientServiceMultiface::add(iface);
    ifaces_.push_back(iface);
  }
 public:
  void startScan(accumulo::data::InitialScan& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const accumulo::data::TRange& range, const std::vector<accumulo::data::TColumn> & columns, const int32_t batchSize, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->startScan(_return, tinfo, credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations, waitForWrites, isolated);
        return;
      } else {
        ifaces_[i]->startScan(_return, tinfo, credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations, waitForWrites, isolated);
      }
    }
  }

  void continueScan(accumulo::data::ScanResult& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->continueScan(_return, tinfo, scanID);
        return;
      } else {
        ifaces_[i]->continueScan(_return, tinfo, scanID);
      }
    }
  }

  void closeScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->closeScan(tinfo, scanID);
    }
  }

  void startMultiScan(accumulo::data::InitialMultiScan& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::ScanBatch& batch, const std::vector<accumulo::data::TColumn> & columns, const std::vector<accumulo::data::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->startMultiScan(_return, tinfo, credentials, batch, columns, ssiList, ssio, authorizations, waitForWrites);
        return;
      } else {
        ifaces_[i]->startMultiScan(_return, tinfo, credentials, batch, columns, ssiList, ssio, authorizations, waitForWrites);
      }
    }
  }

  void continueMultiScan(accumulo::data::MultiScanResult& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->continueMultiScan(_return, tinfo, scanID);
        return;
      } else {
        ifaces_[i]->continueMultiScan(_return, tinfo, scanID);
      }
    }
  }

  void closeMultiScan(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::ScanID scanID) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->closeMultiScan(tinfo, scanID);
    }
  }

  accumulo::data::UpdateID startUpdate(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->startUpdate(tinfo, credentials);
      } else {
        ifaces_[i]->startUpdate(tinfo, credentials);
      }
    }
  }

  void applyUpdates(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID, const accumulo::data::TKeyExtent& keyExtent, const std::vector<accumulo::data::TMutation> & mutations) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->applyUpdates(tinfo, updateID, keyExtent, mutations);
    }
  }

  void closeUpdate(accumulo::data::UpdateErrors& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::data::UpdateID updateID) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->closeUpdate(_return, tinfo, updateID);
        return;
      } else {
        ifaces_[i]->closeUpdate(_return, tinfo, updateID);
      }
    }
  }

  void update(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& keyExtent, const accumulo::data::TMutation& mutation) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->update(tinfo, credentials, keyExtent, mutation);
    }
  }

  void bulkImport(std::vector<accumulo::data::TKeyExtent> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const int64_t tid, const accumulo::data::TabletFiles& files, const bool setTime) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->bulkImport(_return, tinfo, credentials, tid, files, setTime);
        return;
      } else {
        ifaces_[i]->bulkImport(_return, tinfo, credentials, tid, files, setTime);
      }
    }
  }

  void splitTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const accumulo::data::TKeyExtent& extent, const std::string& splitPoint) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->splitTablet(tinfo, credentials, extent, splitPoint);
    }
  }

  void loadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->loadTablet(tinfo, credentials, lock, extent);
    }
  }

  void unloadTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent, const bool save) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->unloadTablet(tinfo, credentials, lock, extent, save);
    }
  }

  void flush(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->flush(tinfo, credentials, lock, tableId, startRow, endRow);
    }
  }

  void flushTablet(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->flushTablet(tinfo, credentials, lock, extent);
    }
  }

  void chop(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const accumulo::data::TKeyExtent& extent) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->chop(tinfo, credentials, lock, extent);
    }
  }

  void compact(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->compact(tinfo, credentials, lock, tableId, startRow, endRow);
    }
  }

  void useLoggers(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::set<std::string> & loggers) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->useLoggers(tinfo, credentials, loggers);
    }
  }

  void getTabletServerStatus(accumulo::master::TabletServerStatus& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getTabletServerStatus(_return, tinfo, credentials);
        return;
      } else {
        ifaces_[i]->getTabletServerStatus(_return, tinfo, credentials);
      }
    }
  }

  void getTabletStats(std::vector<TabletStats> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& tableId) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getTabletStats(_return, tinfo, credentials, tableId);
        return;
      } else {
        ifaces_[i]->getTabletStats(_return, tinfo, credentials, tableId);
      }
    }
  }

  void getHistoricalStats(TabletStats& _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getHistoricalStats(_return, tinfo, credentials);
        return;
      } else {
        ifaces_[i]->getHistoricalStats(_return, tinfo, credentials);
      }
    }
  }

  void halt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->halt(tinfo, credentials, lock);
    }
  }

  void fastHalt(const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials, const std::string& lock) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->fastHalt(tinfo, credentials, lock);
    }
  }

  void getActiveScans(std::vector<ActiveScan> & _return, const accumulo::cloudtrace::TInfo& tinfo, const accumulo::security::AuthInfo& credentials) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getActiveScans(_return, tinfo, credentials);
        return;
      } else {
        ifaces_[i]->getActiveScans(_return, tinfo, credentials);
      }
    }
  }

};

}} // namespace

#endif
